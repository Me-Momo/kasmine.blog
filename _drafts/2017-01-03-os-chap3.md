---
layout: post
tags: 操作系统
title: 进程和线程
---

>   考点：
进程与线程
（1）进程和线程的基本概念，创建，终止，状态，以及使用和实现；
（2）进程的基本状态（运行态，阻塞态）的基本概念和异同点，相互转换的原因和条件；
（3）进程的类别（用户级线程和核心级线程）的基本概念和异同点
（3）进程之间的通信，临界区，互斥，管道和消息传递；
（4）进程调度的策略和机制（几种调度类型），经典的IPC问题（哲学家，读者-写者）；
（5）DOWN、UP操作（例子代码，能举一反三）。
死锁
（1）死锁的基本概念，产生条件，检测方法，避免和预防方法；
（2）经典算法（鸵鸟算法，银行家算法--死锁预防）；
（3）互斥条件


### <center id="#1">名词解析</center>
##### 进程
>  进程：程序在一个数据集合上运行的过程，是程序的一次执行
>  线程：进程的一个实体，系统独立调度和分派的基本单位(拥有程序计数器，堆栈和寄存器，线程标识符)
>  管程：(!)系统中共享资源用数据结构的抽象表示。
>  进程控制块(!)：是进程的唯一标识，保存了系统管理和控制进程所必须的信息。通常包含 进程标识，进程的当前状态，进程的优先级，CPU现场保护区，运行程序的起始地址和进程间的关系。

##### 什么是临界区？什么是临界资源？
>  临界资源：<del>进程在执行过程中必须互斥访问的资源。</del> 指一次只能一个进程使用的资源
临界区：并发进程访问临界资源必须互斥执行的程序段

##### 什么是进程间同步？什么是进程间互斥？
>  <del>进程同步：某一个进程的执行，需要等待另一个进程发送的消息，即使临界资源可访问，进程也不可以执行</del>
进程同步是由于并发进程需要协调执行同一个任务时引起的制约关系，为一个进程等待另一个进程向他直接发送消息或者数据的制约关系
进程互斥：并发进程由于使用系统的临界资源引起的，为一个进程等待另一个进程释放已经占用的必须互斥使用的资源。



### <center id="#2">论述题</center>

##### (!)进程的基本状态（运行态，阻塞态）的基本概念和异同点，相互转换的原因和条件；
>   * 概念：为了刻画一个进程，将其生命周期划分为一组状态，即进程状态。
>   * 特征：(!)动态性、并发性、独立性、制约性、结构性。
* 运行态：正在CPU上运行的进程的状态
* 就绪态：进程已经获得了CPU之外一切资源，等待系统分配CPU，一旦获得了CPU，即立刻变为运行态
* 阻塞态：即正在运行的进程由于等待某一条件而不能运行的状态，即使CPU空闲，也不能投入工作。
<small>
1、进程从就绪状态进入运行状态的原因可能是(B)
2、运行态->阻塞态  (A)
3、运行态->就绪态  (C或者抢占式调度中，有更高优先级的进程变成就绪态)
4、阻塞态->就绪态 (D)
A、等待某一事件  B、发生进程调度  C、时间片用完  D、等待的事件已发生
</small>


##### 说明中断与进程切换的关系
>   中断不是进程切换的充分条件，若中断处理处理完成后原进程不具备继续运行的条件，则会发生进程切换，若具备，则可能发生进程切换，也可能不发生进程切换。
##### 进程的两种状态，挂起状态与阻塞状态的区别？
>   ????[参考](http://blog.csdn.net/paincupid/article/details/51724273)

##### 为什么要区分系统态和用户态？
>   *　为了防止操作系统及关键数据受到用户程序有意或无意的破坏，通常将处理机的执行状态分成系统态和用户态两种。
>   *　处于用户态执行的程序的操作要受到限制，不能去执行特权指令；用户态下的进程能存取它们自己的指令与数据，但不能存取内核指令和数据或其他进程的指令和数据
>   *　用户态的程序通过系统调用接受系统态程序运行的服务。



#####（!）进程调度的策略和机制（几种调度类型）
> * FCFS
> * SJF
> * SRTN
> * 优先级调度算法
> * 时间片轮转算法
> *
> *




========================================算法实战========================================
##### 五、有一阅览室，共有100个座位。读者进入时必须先在一张登记表上登记，该表为每一座位列一表目，包括座号和读者姓名。读者离开时要消掉登记内容。（12分）
(1) 用PV操作管理这些并发进程时，应如何定义信号量，写出信号量的初值以及信号量各种取值的含义。
(2) 用P、V操作描述读者进程的同步结构。
>   座位是一个临界资源，必须互斥使用，引入一个信号量mutex，初值为1，共有100个座位，引入一个信号量seat进行管理，初值为100.


```
#define N 100
typedef semaphore int;
semaphore seat=N;     //座位的数目
semaphore mutex=1;    //控制对缓冲区的访问

void reader_enter(void){
    while(TRUE){
        down(&seat);
        down(&mutex);
        enter();
        up(&mutex);
    }
}
void reader_leave(){  
    while(TRUE){
        down(&mutex);
        leave();
        up(&mutex);
        up(&seat);
    }
}
```

##### 40.假定系统有三个并发进程read, move和print共享缓冲器B1和B2。进程read负责从输入设备上读信息，每读出一个记录后把它存放到缓冲器B1中。进程move从缓冲器B1中取出一记录，加工后存入缓冲器B2。进程print将B2中的记录取出打印输出。<ins>缓冲器B1和B2每次只能存放一个记录。</ins>要求三个进程协调完成任务，使打印出来的与读入的记录的个数，次序完全一样。
   请用PV操作，写出它们的并发程序。
> 每个缓冲区只能存放一个记录，设置四个信号量，分别表示B1，B2缓冲区是否为空和有数据。

```
typedef semaphore int;
semaphore emptyB1=1;   //B1缓冲区的空槽
semaphore emptyB2=1;   //B2缓冲区的空槽
semaphore countB1=0;   //B1缓冲区的数据      
semaphore countB2=0;   //B2缓冲区的数据

void read(void){
    while(TRUE){
        down(&emptyB1);
        read_item_to_B1();
        up(&countB1);
    }
}
void move(void){
    int item;
    while(TRUE){
        down(&countB1);
        item=fetch_item_from_B1();
        up(&emptyB1);
        加工item;
        down(&emptyB2);
        move_B1_to_B2();
        up(&countB2);    
    }
}
void print(void){
    int item;
    while(TRUE){
        down(&countB2);
        item=fetch_item_from_B2();
        up(&emptyB2);
        print_item(item);
    }
}

```
